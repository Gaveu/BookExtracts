[TOC]

# 01.Reversing



将可执行程序反汇编，通过分析反汇编代码来理解其代码功能（例如各接口的数据结构等），然后用高级语言重新描述这段代码，逆向分析原始软件的思路，这个过程就称作逆向工程（Reverse Engineering），有时也简单地称作逆向（Reversing）。

逆向工程可以让我们了解程序的结构及程序的逻辑，因此，利用逆向工程可以洞察程序的运行过程。

## 1.1 32位软件逆向技术

### 启动函数

对于win32应用程序的编写时，我们都需要实现一个`WinMain`函数，但在这个函数开始之前，首先被执行的是启动函数的相关代码。这段代码由编译器生成，用于初始化进程，完成后才会调用`WinMain`函数。对于Visual C++程序亦是如此。

所有c/c++程序运行时，启动函数的作用基本相同，包括检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化和内存栈初始化等。当所有的初始化操作完成后，启动函数就会调用应用程序的进入点函数（`main`和`WinMain`）。调用`WinMain`函数的示例如下：

```c++
GetStartupInfo (&StartupInfo);
Int nMainRetVal = WinMain(GetModuleHandle(NULL),
                          NULL,
                          pszCommandLineAnsi,
                          (StartupInfo.dwFlags&STARTF_USESHOWWINDOW)?
                          StartupInfo.wShowWindow:SW_SHOWDEFFAULT);
```

进入点返回时，启动函数便调用C运行库的`exit`函数，将返回值`nMainRetVal`传递给它，进行一些必要的处理，最后调用系统函数`ExitProcess`退出。

开发人员可以修改启动源代码，但这样做会导致即使是同一编译器，生成的启动代码也不同。在分析程序的过程中，可以略过启动代码，直接将重点放到WinMain函数体上。

### 函数

程序都是由具有不同功能的函数组成的，因此在逆向分析中将重点放在函数的识别及参数的传递上是明智的。这样做可以将注意力集中在某一段代码上。函数是一个程序模块，用来实现一个特定的功能。一个函数包括函数名、入口参数、返回值、函数功能等部分。

#### 函数的识别

程序通过调用程序来调用函数，在程序执行后又返回调用程序继续执行。调用函数的代码中保存了一个返回地址，该地址会与参数一起传递给被调用的函数。有多种方法可以实现这个功能，在绝大多数的情况下，编译器都会使用`call`和`ret`指令来调用函数及返回调用位置。

`call`指令与跳转指令功能类似，但`call`指令保存返回信息，即将其之后的指令地址压入栈的顶部，当遇到`ret`指令时返回这个地址。`call`指令给出的地址就是被调用函数的起始地址。`ret`指令则用于结束函数的执行。通过这个机制可以很容易地把函数调用和其他跳转指令区别开来。

因此，可以通过定位`call`指令或者利用`ret`指令结束的标志来识别函数。`call`指令的操作数就是所调用函数的首地址。

```c
#include<stdio.h>

int Add(int x,int y);

main()
{
	int a=5,b=6;
	Add(a,b);
	return 0;
}

Add(int x,int y)
{
	return (x+y);
}

```



``` shell
 gcc -m32 -o main main.c
 objdump -d main -M intel,i386

00000000000005fa <main>:
 5fa:	55                   	push   ebp
 5fb:	48                   	dec    eax
 5fc:	89 e5                	mov    ebp,esp
 5fe:	48                   	dec    eax
 5ff:	83 ec 10             	sub    esp,0x10
 602:	c7 45 f8 05 00 00 00 	mov    DWORD PTR [ebp-0x8],0x5
 609:	c7 45 fc 06 00 00 00 	mov    DWORD PTR [ebp-0x4],0x6
 610:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 613:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
 616:	89 d6                	mov    esi,edx
 618:	89 c7                	mov    edi,eax
 61a:	e8 07 00 00 00       	call   626 <Add>	//此处调用Add()函数，0x626为其函数首地址
 61f:	b8 00 00 00 00       	mov    eax,0x0
 624:	c9                   	leave  
 625:	c3                   	ret    

0000000000000626 <Add>:
 626:	55                   	push   ebp
 627:	48                   	dec    eax
 628:	89 e5                	mov    ebp,esp
 62a:	89 7d fc             	mov    DWORD PTR [ebp-0x4],edi
 62d:	89 75 f8             	mov    DWORD PTR [ebp-0x8],esi
 630:	8b 55 fc             	mov    edx,DWORD PTR [ebp-0x4]
 633:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
 636:	01 d0                	add    eax,edx
 638:	5d                   	pop    ebp
 639:	c3                   	ret		//这是Add()函数的结尾，以ret作结
 63a:	66 0f 1f 44 00 00    	nop    WORD PTR [eax+eax*1+0x0]

```



#### 函数的参数

函数传递参数有三种方式：栈方式、寄存器方式及通过全局变量进行隐含参数传递方式。

1. 利用栈传递参数：

   栈是一种“后进后出”的存储区，栈顶指针`esp`指向栈中第1个可用的数据项。在调用函数时，调用者依次把参数压入栈中，然后调用函数。函数被调用后，在栈中取得数据并进行计算。计算完毕后，由调用者或者函数本身修改栈，使栈恢复原样（即平衡栈数据）。

   在程序设计语言中为了实现函数调用而建议的协议称为调用约定。这种协议规定了函数中参数的传送方式、参数是否可变和由谁来处理栈平衡等问题。不同的语言定义了不同的调用约定：

   | 约定类型       | __cdecl(c规范) | pascal   | stdcall  | Fastcall |
   | -------------- | -------------- | -------- | -------- | -------- |
   | 参数传递顺序   | 从右到左       | 从左到右 | 从右到左 | 从右到左 |
   | 平衡栈者       | 调用者         | 子程序   | 子程序   | 子程序   |
   | 允许使用VARARG | 是             | 否       | 是       |          |

   `__cdecl`是c和c++程序的默认调用约定。c/c++和MFC程序默认使用的调用约定就是`__cdecl`，也可以在函数声明时加上`__cdecl`关键字来手动指定。

   `pascal`规范按从左到右的顺序压参入栈，要求被调用函数负责栈平衡

   `stdcall`调用约定是Win32 API采用的约定方式，有“标准调用”之意，如果有使用`VARARG`参数类型，就是调用程序平衡栈，否则就是子程序平衡栈。

   ```asm
   __cdecl:
   push par3	;参数从右往左传递
   push par2
   push par1
   call test1	;平衡栈
   add esp,0xc
   
   __pascal:
   push par1	;参数从左往右传递
   push par2
   push par3
   call test1	;函数内平衡栈
   
   __stdcall:
   push par3	;参数从右往左传递
   push par2
   push par1
   call test1	;函数内平衡栈
   ```

   函数对参数的存取及局部变量都是通过栈来定义的，非优化编译器用一个专门的寄存器（通常是`ebp`）对参数进行寻址。c、c++、pascal等高级语言的函数（子程序）执行过程基本一致：

   - 调用者将函数（子程序）执行完毕时应返回的地址、参数压栈
   - 子程序使用`ebp+偏移量`对栈中的参数进行寻址并取出，完成操作
   - 子程序使用`ret`或者`ref`指令返回。此时CPU将`eip`置为栈中保存的地址，并继续执行。

   在许多时候，编译器会按优化方式来编译程序，栈寻址稍有不同。这时编译器为了节省`ebp`寄存器或尽可能减少代码以提高速度，会直接通过`esp`对参数进行寻址。

2. 利用寄存器传递参数：

   寄存器传递参数的方式没有标准，所有与平台相关的方式都是由编译器开发人员制定的。尽管没有标准，但绝大多数编译器提供商都在不对兼容性进行声明的情况下遵循相应的规范，即`Fastcall`规范。

   另一类调用规范`thiscall`也用到了寄存器传递参数。`thiscall`是c++中非静态类成员函数的默认调用约定，对象的每个函数隐含接受this参数。采用`thiscall`约定时，函数的参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，仅通过`ecx`传送一个额外的参数——this指针。

3. 名称修饰约定：

   为了允许使用操作符和函数重载，c++编译器往往会按照某种规则改写每一个入口点的符号名，从而允许同一个名字（具有不同的参数类型或者不同作用域）有多个用法且不会破坏现有的基于C的连接器。这项技术通常成为名称改编或者名称修饰。

   c编译时函数名修饰约定规则如下：

   - `stdcall`在输出函数名前面加一个下划线前缀，后面加一个“@”及其参数的字节数，格式为“_functionname@number”
   - `__cdecl`仅在输出函数名前面加一个下划线前缀，格式为“_functionname”
   - `Fastcall`在输出函数名前面加一个“@”，在后面加一个“@”及其参数的字节数，格式为“@functionname@number”

   它们均不改变输出函数名中的字符大小写。这个`pascal`调用约定不同。`pascal`约定输出的函数名不能有任何修饰且全部为大写。

   c++编译时函数名修饰约定规则如下：

   - `stdcall`以“？”标识函数名的开始，后跟函数名；在函数吗后面，以“@@YG”表示参数表的开始，后跟参数表；参数表的第1项为该函数的返回值类型，其后依次为参数的数据类型，指针标识在其所指数据类型前；在参数表后面，以“@Z”标识整个名字的结束（如果该函数没有参数，则以“Z”标识结束）。其格式为“？functionname@@YG\*\*\*\*\*@Z”或“？functionname@@YG\*XZ”
   - `__cdecl`调用约定规则与上面`stdcall`调用约定规则一致，只是参数表的开始标识由“@@YG”变成了“@@YA”
   - `Fastcall`调用约定规则与上面`stdcall`调用约定规则一致，只是参数表的开始标识由“@@YG”变成了“@@YI”



#### 函数的返回值

函数被调用执行后，将向调用者返回1个或者多个执行结果，称为函数返回值。返回值最常见的形式是return操作符，还有通过按传参引用方式返回值、通过全局变量返回值等。

1. 用return操作符返回值：

   ```c
   #include<stdio.h>
   
   int myAdd(int x,int y);
   
   int main()
   {
   	int a=5,b=6;
   	myAdd(a,b);
   
   	return 0;
   }
   
   int myAdd(int x,int y)
   {
   	int temp;
   	temp = x+y;
   	return temp;
   }
   ```

   ```shell
   gcc -m32 -o main mian.c
   objdump -d main -M intel
   
   000004ed <main>:
    4ed:	8d 4c 24 04          	lea    ecx,[esp+0x4]
    4f1:	83 e4 f0             	and    esp,0xfffffff0
    4f4:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
    4f7:	55                   	push   ebp
    4f8:	89 e5                	mov    ebp,esp
    4fa:	51                   	push   ecx
    4fb:	83 ec 14             	sub    esp,0x14
    4fe:	e8 51 00 00 00       	call   554 <__x86.get_pc_thunk.ax>
    503:	05 d9 1a 00 00       	add    eax,0x1ad9
    508:	c7 45 f0 05 00 00 00 	mov    DWORD PTR [ebp-0x10],0x5	；变量a
    50f:	c7 45 f4 06 00 00 00 	mov    DWORD PTR [ebp-0xc],0x6	；变量b
    516:	83 ec 08             	sub    esp,0x8
    519:	ff 75 f4             	push   DWORD PTR [ebp-0xc]	
    51c:	ff 75 f0             	push   DWORD PTR [ebp-0x10]	；从右往左传参
    51f:	e8 10 00 00 00       	call   534 <myAdd>
    524:	83 c4 10             	add    esp,0x10
    527:	b8 00 00 00 00       	mov    eax,0x0
    52c:	8b 4d fc             	mov    ecx,DWORD PTR [ebp-0x4]
    52f:	c9                   	leave  
    530:	8d 61 fc             	lea    esp,[ecx-0x4]
    533:	c3                   	ret    
   
   00000534 <myAdd>:
    534:	55                   	push   ebp
    535:	89 e5                	mov    ebp,esp
    537:	83 ec 10             	sub    esp,0x10
    53a:	e8 15 00 00 00       	call   554 <__x86.get_pc_thunk.ax>
    53f:	05 9d 1a 00 00       	add    eax,0x1a9d
    544:	8b 55 08             	mov    edx,DWORD PTR [ebp+0x8]	;取第一个参数，即a
    547:	8b 45 0c             	mov    eax,DWORD PTR [ebp+0xc]	;取第二个参数，即b
    54a:	01 d0                	add    eax,edx
    54c:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax	;[ebp-0x4]即为temp
    54f:	8b 45 fc             	mov    eax,DWORD PTR [ebp-0x4]	;return值传给eax，然后结束
    552:	c9                   	leave  
    553:	c3                   	ret    
   
   ```

2. 通过参数按引用方式返回值：

   给函数传递参数的方式有两种，分别是传值和传引用。进行传值调用时，会建立参数的一份复本，并把它传给调用参数，在调用函数中修改参数值的副本不会影响原始的变量值。传引用调用允许调用函数修改原始变量的值。调用某个函数，当把变量的地址传递给函数时，可以在函数中通过间接引用运算符修改调用函数内存单元中该变量的值。

   ```c++
   #include<iostream>
   using namespace std;
   
   int max1(int &a,int &b)
   {
   	if(a >= b)
   	{
   		return a;
   	}
   	return b;
   }
   
   int max2(int *a,int *b)
   {
   	if(*a >= *b)
   	{
   		return *a;	
   	}
   	return *b;
   }
   
   int main()
   {
   	int a=5,b=6;
   	int result;
   	result = max1(a,b);
   	result = max2(&a,&b);
   
   	return 0;
   }
   
   ```

   ``` assembly
   g++ -o main main.cpp
   objdump -d main -M intel,i386
   00000000000007aa <_Z4max1RiS_>:
    7aa:	55                   	push   ebp
    7ab:	48                   	dec    eax
    7ac:	89 e5                	mov    ebp,esp
    7ae:	48                   	dec    eax
    7af:	89 7d f8             	mov    DWORD PTR [ebp-0x8],edi
    7b2:	48                   	dec    eax
    7b3:	89 75 f0             	mov    DWORD PTR [ebp-0x10],esi
    7b6:	48                   	dec    eax
    7b7:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
    7ba:	8b 10                	mov    edx,DWORD PTR [eax]
    7bc:	48                   	dec    eax
    7bd:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
    7c0:	8b 00                	mov    eax,DWORD PTR [eax]
    7c2:	39 c2                	cmp    edx,eax
    7c4:	7c 08                	jl     7ce <_Z4max1RiS_+0x24>
    7c6:	48                   	dec    eax
    7c7:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
    7ca:	8b 00                	mov    eax,DWORD PTR [eax]
    7cc:	eb 06                	jmp    7d4 <_Z4max1RiS_+0x2a>
    7ce:	48                   	dec    eax
    7cf:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
    7d2:	8b 00                	mov    eax,DWORD PTR [eax]
    7d4:	5d                   	pop    ebp
    7d5:	c3                   	ret    
   
   00000000000007d6 <_Z4max2PiS_>:
    7d6:	55                   	push   ebp
    7d7:	48                   	dec    eax
    7d8:	89 e5                	mov    ebp,esp
    7da:	48                   	dec    eax
    7db:	89 7d f8             	mov    DWORD PTR [ebp-0x8],edi
    7de:	48                   	dec    eax
    7df:	89 75 f0             	mov    DWORD PTR [ebp-0x10],esi
    7e2:	48                   	dec    eax
    7e3:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
    7e6:	8b 10                	mov    edx,DWORD PTR [eax]
    7e8:	48                   	dec    eax
    7e9:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
    7ec:	8b 00                	mov    eax,DWORD PTR [eax]
    7ee:	39 c2                	cmp    edx,eax
    7f0:	7c 08                	jl     7fa <_Z4max2PiS_+0x24>
    7f2:	48                   	dec    eax
    7f3:	8b 45 f8             	mov    eax,DWORD PTR [ebp-0x8]
    7f6:	8b 00                	mov    eax,DWORD PTR [eax]
    7f8:	eb 06                	jmp    800 <_Z4max2PiS_+0x2a>
    7fa:	48                   	dec    eax
    7fb:	8b 45 f0             	mov    eax,DWORD PTR [ebp-0x10]
    7fe:	8b 00                	mov    eax,DWORD PTR [eax]
    800:	5d                   	pop    ebp
    801:	c3                   	ret    
   
   0000000000000802 <main>:
    802:	55                   	push   ebp
    803:	48                   	dec    eax
    804:	89 e5                	mov    ebp,esp
    806:	48                   	dec    eax
    807:	83 ec 20             	sub    esp,0x20
    80a:	64 48                	fs dec eax
    80c:	8b 04 25 28 00 00 00 	mov    eax,DWORD PTR [eiz*1+0x28]
    813:	48                   	dec    eax
    814:	89 45 f8             	mov    DWORD PTR [ebp-0x8],eax
    817:	31 c0                	xor    eax,eax
    819:	c7 45 ec 05 00 00 00 	mov    DWORD PTR [ebp-0x14],0x5
    820:	c7 45 f0 06 00 00 00 	mov    DWORD PTR [ebp-0x10],0x6
    827:	48                   	dec    eax
    828:	8d 55 f0             	lea    edx,[ebp-0x10]
    82b:	48                   	dec    eax
    82c:	8d 45 ec             	lea    eax,[ebp-0x14]
    82f:	48                   	dec    eax
    830:	89 d6                	mov    esi,edx
    832:	48                   	dec    eax
    833:	89 c7                	mov    edi,eax
    835:	e8 70 ff ff ff       	call   7aa <_Z4max1RiS_>
    83a:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
    83d:	48                   	dec    eax
    83e:	8d 55 f0             	lea    edx,[ebp-0x10]
    841:	48                   	dec    eax
    842:	8d 45 ec             	lea    eax,[ebp-0x14]
    845:	48                   	dec    eax
    846:	89 d6                	mov    esi,edx
    848:	48                   	dec    eax
    849:	89 c7                	mov    edi,eax
    84b:	e8 86 ff ff ff       	call   7d6 <_Z4max2PiS_>
    850:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
    853:	b8 00 00 00 00       	mov    eax,0x0
    858:	48                   	dec    eax
    859:	8b 4d f8             	mov    ecx,DWORD PTR [ebp-0x8]
    85c:	64 48                	fs dec eax
    85e:	33 0c 25 28 00 00 00 	xor    ecx,DWORD PTR [eiz*1+0x28]
    865:	74 05                	je     86c <main+0x6a>
    867:	e8 04 fe ff ff       	call   670 <__stack_chk_fail@plt>
    86c:	c9                   	leave  
    86d:	c3                   	ret    
   
   ```


### 数据结构

数据结构是计算机存储、组织数据的方式。在进行逆向分析时，确定数据结构以后，算法就很容易得到了。有些时候，事情也会反过来，即依据特定算法来判断数据结构。

















































