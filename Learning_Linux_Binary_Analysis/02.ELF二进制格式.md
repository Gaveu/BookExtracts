[TOC]

# 02.ELF二进制格式

要反编译Linux二进制文件，首先需要理解二进制本身。ELF跟程序加载、动态链接、符号表查找和许多其他精心设计的组件一样，都是计算机科学非常重要的一部分。程序执行的内部逻辑比较复杂，对于有抱负的二进制黑客、逆向工程工程师或者普通的程序员来说，对二进制格式的理解将会是非常宝贵的知识财富。

## ELF文件类型

一个ELF文件可以被标记为以下的几种类型：

- ET_NONE：未知类型。表明文件类型不确定，或者还未定义。
- ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据。
- ET_EXEC：可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件。这种类型的文件也称为程序，是一个进程开始执行的入口。
- ET_DYN：共享目标文件。ELF类型为dynamic，意味着该文件被标记为一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中。
- ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因。

使用`readelf -h`命令查看ELF文件，可以看到原始的ELF文件头。ELF文件头从文件的0偏移量开始，是除了文件头之后剩余部分文件的一个映射。

## ELF程序头

ELF程序头是对二进制文件中段的描述，是程序装载必须的一部分。段（segment）是内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）的偏移量来得到程序头表。

下面讨论五种常见的程序头类型，它们描述了可执行文件（包括共享库）中的段以及其类型（为哪种类型的数据或代码而保留的段）。

Elf32_Phdr结构体

```c++
typedef struct{
	uint32_t p_type;(segment type) 
	Elf32_Off p_offset;(segment offset)
	Elf32_Addr p_vaddr; (segment virtual address)
	Elf32_Addr p_paddr; (segment physical address) 
	uint32_t p_filesz; (size of segment in the file) 
	uint32_t p_memsz; (size of segment in memory) 
	uint32_t p_flags; (segment flags, I.E execute|read|read) 
	uint32_t p_align; (segment alignment in memory)
} Elf32_Phdr;
```



### PT_LOAD

一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。

> 通常将text段（也称代码段）的权限设置为PF_X|PF_R（读和可执行）。
>
> 通常将data段的权限设置为PF_W|PF_R（读和写）。
>
> 感染了千面人病毒（polymorphic virus）文件的text段或data段的权限可能会被修改，如通过在程序头的段标记（p_flags）出增加PF_W标记来修改text段的权限。

### PT_DYNAMIC——动态段的Phdr

动态段是动态链接可执行文件所持有的，包含了动态链接器所必须的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：

- 运行时需要链接的共享库列表；
- **全局偏移表（GOT）**的地址；
- 重定位条目的相关信息。

完整的标记名列表：

| Tag name/标记名 | 描述                                                       |
| --------------- | ---------------------------------------------------------- |
| DT_HASH         | 符号散列表的地址                                           |
| DT_STRTAB       | 字符串表的地址                                             |
| DT_SYMTAB       | 符号表的地址                                               |
| DT_RELA         | 相对地址重定位表的地址                                     |
| DT_RELASZ       | Rela表的字节大小                                           |
| DT_RELAENT      | Rela表条目的字节大小                                       |
| DT_STRSZ        | 字符串表的字节大小                                         |
| DT_SYMENT       | 符号表条目的字节大小                                       |
| DT_INIT         | 初始化函数的地址                                           |
| DT_FINT         | 终止函数的地址                                             |
| DT_SONAME       | 共享目标文件名的字符串表偏移量                             |
| DT_RPATH        | 库搜索路径的字符串表偏移量                                 |
| DT_SYMBOLIC     | 修改链接器，在可执行文件之前的共享目标文件中搜索符号       |
| DT_REL          | Rel relocs表的地址                                         |
| DT_RELSZ        | Rel表的字节大小                                            |
| DT_RELENT       | Rel表条目的字节大小                                        |
| DT_PLTREL       | PLT引用的reloc类型（Rela或Rel）                            |
| DT_DEBUG        | 还未进行定义，为测试保留                                   |
| DT_TEXTREL      | 缺少此项表明重定位只能应用于可写段                         |
| DT_JMPREL       | 仅用于PLT的重定位条目地址                                  |
| DT_BIND_NOW     | 指示动态链接器在将控制权交给可执行文件之前处理所有的重定位 |
| DT_RUNPATH      | 库搜索路径的字符串表偏移量                                 |

### PT_NOTE

PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加信息。事实上，这一段质保存了操作系统的规范信息，在可执行文件运行时是不需要这个段的（因为系统会假设一个可执行文件是本地的），这个段成了很容易被病毒感染的一个地方。

### PT_INTERP

PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。

### PT_PHDR

PT_PHDR段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。可以使用**readelf -l <filename>**命令来查看文件的Phdr表。

## ELF节头

节（section），不是段（segment）。段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对程序的执行不是必需的，是对程序头的补充。**readelf -l**命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。

每个ELF目标文件都有节，但是不一定有**节头**，尤其是有人故意将节头从节头表中删除了之后。当然，默认是节头的。通常，这是由于可执行文件被篡改导致的（如去掉节头来增加调试的难度）。GNU的**binutils**工具，像objcopy、objdump，还有gdb等，都需要依赖节头定位到存储符号数据的节来获取符号信息。如果没有节头，gdb和objdump这样的工具几乎无用武之地。

有了节头，一些诸如objdump之类需要使用节头的工具就能为逆向工程带来很多便利。如果去掉了节头表，就无法获取像**.dynsym**这样的节，而在**.dynsym**节中包含了描述函数名和偏移量/地址的导入/导出符号。

> 即便一个可执行文件中去掉了节头表，我们也可以通过特定的程序头中获取相关信息来重构节头表（甚至重构部分符号表），因为一个程序或者共享库中一定是存在程序头的。可以利用动态段以及各种保存了符号表和重定位入口信息的DT_TAG来重构可执行文件的其余部分。

下面介绍一些比较重要的节和节类型。

### .text节

.text节保存了程序代码指令的代码节。如果可执行程序存在Phdr，.text节就会存在与text段中。该节的类型为SHT_PROGBITS。

### .rodata节

.rodata保留只读数据，只能存在于一个可执行文件的只读段中。因此，只能在text段中找到.rodata节。该节类型为SHT_PROGBITS。

### .plt节

.plt节中包含了动态链接器调用从共享库导入的函数所必需的相关代码，存在于text段中，节类型为SHT_PROGBITS。

### .data节

.data节存在于data段中，保存了初始化的全局变量等数据。由于其保存了程序的变量数据，因此类型被标记为SHT_PROGBITS。

### .bss节

.bss节保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。节类型为SHT_NOBITS。

### .got .plt节

.got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。当攻击者获得了堆或者.bss漏洞的一个指针大小的写原语，就可以对该节任意进行修改。.got .plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。



### 

