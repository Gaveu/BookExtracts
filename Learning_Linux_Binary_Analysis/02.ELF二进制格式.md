[TOC]

# 02.ELF二进制格式

要反编译Linux二进制文件，首先需要理解二进制本身。ELF跟程序加载、动态链接、符号表查找和许多其他精心设计的组件一样，都是计算机科学非常重要的一部分。程序执行的内部逻辑比较复杂，对于有抱负的二进制黑客、逆向工程工程师或者普通的程序员来说，对二进制格式的理解将会是非常宝贵的知识财富。

## ELF文件类型

一个ELF文件可以被标记为以下的几种类型：

- ET_NONE：未知类型。表明文件类型不确定，或者还未定义。
- ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据。
- ET_EXEC：可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件。这种类型的文件也称为程序，是一个进程开始执行的入口。
- ET_DYN：共享目标文件。ELF类型为dynamic，意味着该文件被标记为一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中。
- ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因。

使用`readelf -h`命令查看ELF文件，可以看到原始的ELF文件头。ELF文件头从文件的0偏移量开始，是除了文件头之后剩余部分文件的一个映射。

## ELF程序头

ELF程序头是对二进制文件中段的描述，是程序装载必须的一部分。段（segment）是内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）的偏移量来得到程序头表。

下面讨论五种常见的程序头类型，它们描述了可执行文件（包括共享库）中的段以及其类型（为哪种类型的数据或代码而保留的段）。

Elf32_Phdr结构体

```c++
typedef struct{
	uint32_t p_type;(segment type) 
	Elf32_Off p_offset;(segment offset)
	Elf32_Addr p_vaddr; (segment virtual address)
	Elf32_Addr p_paddr; (segment physical address) 
	uint32_t p_filesz; (size of segment in the file) 
	uint32_t p_memsz; (size of segment in memory) 
	uint32_t p_flags; (segment flags, I.E execute|read|read) 
	uint32_t p_align; (segment alignment in memory)
} Elf32_Phdr;
```



### PT_LOAD

一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。

> 通常将text段（也称代码段）的权限设置为PF_X|PF_R（读和可执行）。
>
> 通常将data段的权限设置为PF_W|PF_R（读和写）。
>
> 感染了千面人病毒（polymorphic virus）文件的text段或data段的权限可能会被修改，如通过在程序头的段标记（p_flags）出增加PF_W标记来修改text段的权限。

### PT_DYNAMIC——动态段的Phdr

动态段是动态链接可执行文件所持有的，包含了动态链接器所必须的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：

- 运行时需要链接的共享库列表；
- **全局偏移表（GOT）**的地址；
- 重定位条目的相关信息。

完整的标记名列表：

| Tag name/标记名 | 描述                                                       |
| --------------- | ---------------------------------------------------------- |
| DT_HASH         | 符号散列表的地址                                           |
| DT_STRTAB       | 字符串表的地址                                             |
| DT_SYMTAB       | 符号表的地址                                               |
| DT_RELA         | 相对地址重定位表的地址                                     |
| DT_RELASZ       | Rela表的字节大小                                           |
| DT_RELAENT      | Rela表条目的字节大小                                       |
| DT_STRSZ        | 字符串表的字节大小                                         |
| DT_SYMENT       | 符号表条目的字节大小                                       |
| DT_INIT         | 初始化函数的地址                                           |
| DT_FINT         | 终止函数的地址                                             |
| DT_SONAME       | 共享目标文件名的字符串表偏移量                             |
| DT_RPATH        | 库搜索路径的字符串表偏移量                                 |
| DT_SYMBOLIC     | 修改链接器，在可执行文件之前的共享目标文件中搜索符号       |
| DT_REL          | Rel relocs表的地址                                         |
| DT_RELSZ        | Rel表的字节大小                                            |
| DT_RELENT       | Rel表条目的字节大小                                        |
| DT_PLTREL       | PLT引用的reloc类型（Rela或Rel）                            |
| DT_DEBUG        | 还未进行定义，为测试保留                                   |
| DT_TEXTREL      | 缺少此项表明重定位只能应用于可写段                         |
| DT_JMPREL       | 仅用于PLT的重定位条目地址                                  |
| DT_BIND_NOW     | 指示动态链接器在将控制权交给可执行文件之前处理所有的重定位 |
| DT_RUNPATH      | 库搜索路径的字符串表偏移量                                 |

### PT_NOTE

PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加信息。事实上，这一段质保存了操作系统的规范信息，在可执行文件运行时是不需要这个段的（因为系统会假设一个可执行文件是本地的），这个段成了很容易被病毒感染的一个地方。

### PT_INTERP

PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。

### PT_PHDR

PT_PHDR段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。可以使用**readelf -l <filename>**命令来查看文件的Phdr表。

