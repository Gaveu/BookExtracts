[TOC]

# 02.ELF二进制格式

要反编译Linux二进制文件，首先需要理解二进制本身。ELF跟程序加载、动态链接、符号表查找和许多其他精心设计的组件一样，都是计算机科学非常重要的一部分。程序执行的内部逻辑比较复杂，对于有抱负的二进制黑客、逆向工程工程师或者普通的程序员来说，对二进制格式的理解将会是非常宝贵的知识财富。

## ELF文件类型

一个ELF文件可以被标记为以下的几种类型：

- ET_NONE：未知类型。表明文件类型不确定，或者还未定义。
- ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据。
- ET_EXEC：可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件。这种类型的文件也称为程序，是一个进程开始执行的入口。
- ET_DYN：共享目标文件。ELF类型为dynamic，意味着该文件被标记为一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中。
- ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因。

使用`readelf -h`命令查看ELF文件，可以看到原始的ELF文件头。ELF文件头从文件的0偏移量开始，是除了文件头之后剩余部分文件的一个映射。

## ELF程序头

ELF程序头是对二进制文件中段的描述，是程序装载必须的一部分。段（segment）是内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）的偏移量来得到程序头表。

下面讨论五种常见的程序头类型，它们描述了可执行文件（包括共享库）中的段以及其类型（为哪种类型的数据或代码而保留的段）。

Elf32_Phdr结构体

```c++
typedef struct{
	uint32_t p_type;(segment type) 
	Elf32_Off p_offset;(segment offset)
	Elf32_Addr p_vaddr; (segment virtual address)
	Elf32_Addr p_paddr; (segment physical address) 
	uint32_t p_filesz; (size of segment in the file) 
	uint32_t p_memsz; (size of segment in memory) 
	uint32_t p_flags; (segment flags, I.E execute|read|read) 
	uint32_t p_align; (segment alignment in memory)
} Elf32_Phdr;
```



### PT_LOAD

一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。

> 通常将text段（也称代码段）的权限设置为PF_X|PF_R（读和可执行）。
>
> 通常将data段的权限设置为PF_W|PF_R（读和写）。
>
> 感染了千面人病毒（polymorphic virus）文件的text段或data段的权限可能会被修改，如通过在程序头的段标记（p_flags）出增加PF_W标记来修改text段的权限。

### PT_DYNAMIC——动态段的Phdr

动态段是动态链接可执行文件所持有的，包含了动态链接器所必须的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：

- 运行时需要链接的共享库列表；
- **全局偏移表（GOT）**的地址；
- 重定位条目的相关信息。

完整的标记名列表：

| Tag name/标记名 | 描述                                                       |
| --------------- | ---------------------------------------------------------- |
| DT_HASH         | 符号散列表的地址                                           |
| DT_STRTAB       | 字符串表的地址                                             |
| DT_SYMTAB       | 符号表的地址                                               |
| DT_RELA         | 相对地址重定位表的地址                                     |
| DT_RELASZ       | Rela表的字节大小                                           |
| DT_RELAENT      | Rela表条目的字节大小                                       |
| DT_STRSZ        | 字符串表的字节大小                                         |
| DT_SYMENT       | 符号表条目的字节大小                                       |
| DT_INIT         | 初始化函数的地址                                           |
| DT_FINT         | 终止函数的地址                                             |
| DT_SONAME       | 共享目标文件名的字符串表偏移量                             |
| DT_RPATH        | 库搜索路径的字符串表偏移量                                 |
| DT_SYMBOLIC     | 修改链接器，在可执行文件之前的共享目标文件中搜索符号       |
| DT_REL          | Rel relocs表的地址                                         |
| DT_RELSZ        | Rel表的字节大小                                            |
| DT_RELENT       | Rel表条目的字节大小                                        |
| DT_PLTREL       | PLT引用的reloc类型（Rela或Rel）                            |
| DT_DEBUG        | 还未进行定义，为测试保留                                   |
| DT_TEXTREL      | 缺少此项表明重定位只能应用于可写段                         |
| DT_JMPREL       | 仅用于PLT的重定位条目地址                                  |
| DT_BIND_NOW     | 指示动态链接器在将控制权交给可执行文件之前处理所有的重定位 |
| DT_RUNPATH      | 库搜索路径的字符串表偏移量                                 |

### PT_NOTE

PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加信息。事实上，这一段质保存了操作系统的规范信息，在可执行文件运行时是不需要这个段的（因为系统会假设一个可执行文件是本地的），这个段成了很容易被病毒感染的一个地方。

### PT_INTERP

PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。

### PT_PHDR

PT_PHDR段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。可以使用**readelf -l <filename>**命令来查看文件的Phdr表。

## ELF节头

节（section），不是段（segment）。段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对程序的执行不是必需的，是对程序头的补充。**readelf -l**命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。

每个ELF目标文件都有节，但是不一定有**节头**，尤其是有人故意将节头从节头表中删除了之后。当然，默认是节头的。通常，这是由于可执行文件被篡改导致的（如去掉节头来增加调试的难度）。GNU的**binutils**工具，像objcopy、objdump，还有gdb等，都需要依赖节头定位到存储符号数据的节来获取符号信息。如果没有节头，gdb和objdump这样的工具几乎无用武之地。

有了节头，一些诸如objdump之类需要使用节头的工具就能为逆向工程带来很多便利。如果去掉了节头表，就无法获取像**.dynsym**这样的节，而在**.dynsym**节中包含了描述函数名和偏移量/地址的导入/导出符号。

> 即便一个可执行文件中去掉了节头表，我们也可以通过特定的程序头中获取相关信息来重构节头表（甚至重构部分符号表），因为一个程序或者共享库中一定是存在程序头的。可以利用动态段以及各种保存了符号表和重定位入口信息的DT_TAG来重构可执行文件的其余部分。

下面介绍一些比较重要的节和节类型。

### .text节

.text节保存了程序代码指令的代码节。如果可执行程序存在Phdr，.text节就会存在与text段中。该节的类型为SHT_PROGBITS。

### .rodata节

.rodata保留只读数据，只能存在于一个可执行文件的只读段中。因此，只能在text段中找到.rodata节。该节类型为SHT_PROGBITS。

### .plt节

.plt节中包含了动态链接器调用从共享库导入的函数所必需的相关代码，存在于text段中，节类型为SHT_PROGBITS。

### .data节

.data节存在于data段中，保存了初始化的全局变量等数据。由于其保存了程序的变量数据，因此类型被标记为SHT_PROGBITS。

### .bss节

.bss节保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。节类型为SHT_NOBITS。

### .got .plt节

.got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。当攻击者获得了堆或者.bss漏洞的一个指针大小的写原语，就可以对该节任意进行修改。.got .plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。

### .dynsym节

.dynsym节保存了从共享库导入的动态符号信息，该节保存在text段中，节类型被标记为SHT_DYNSYM。

### .dynstr节

.dynstr节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，以空字符作为终止符。

### .rel.*节

重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对ELF目标文件的某部分内容或者进程镜像进行补充或修改。节类型被标记为SHT_REL。

### .hash节

.hash节有时也称为.gnu.hash，保存了一个用于查找符号的散列表。

### .symtab节

.symtab节保存了ElfN_Sym类型的符号信息，节类型被标记为SHT_SYMTAB。

### .strtab节

.strtab节保存的是符号字符串表，表中的内容会被.symtab的ElfN_Sym结构中的st_name条目引用，节类型被标记为SHT_STRTAB。

### .shstrtab节

.shstrtab节保存节头字符串表，该表是一个以空字符终止的字符串的集合，字符串保存了每个节的节名，如.text、.data等，节类型被标记为SHT_STRTAB。

### .ctors和.dtors节

.ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。

> 黑客或者病毒制造者有时会利用构造函数属性实现一个函数，实现类似与PTRACE_TRAVEME这样的反调试功能，这样进程就会追踪自身，调试其就无法附加到这个进程上。通过这种方式，在程序进入main()函数之前就会先执行反调试的代码。

可以使用**readelf -S**命令查看ET_REL文件（目标文件）的节头。

可重定位文件(类型为ET_REL的ELF文件)中不存在程序头，因为.o类型的文件会被链接到可执行文件中，但是不会被直接加载到内存中，所以使用**readelf -l**命令不会得到想要的结果。不过LKM(linux中的可加载内核模块)是个例外，LKM是ET_REL类型的文件，它会被直接加载进内核的内存中并自动进行重定位。

## ELF符号

符号是对某些类型的数据或者代码（如全局变量或函数）的符号引用。例如，printf()函数会在动态符号表.dynsym中存有一个指向该函数的符号条目。在大多数共享库和动态链接可执行文件中，存在两个符号表：.dynsym和.symtab。

.dynsym保存了引用来自外部文件符号的全局符号（如printf这样的库函数），而.symtab中不仅保留了.dymsym中符号，还保存了可执行文件的本地符号，如全局变量，或者代码中定义的本地函数等。因此，.symtab保存了所有的符号，而.dynsym只保存动态/全局符号。

但是，使用**readelf -S**命令可以查看可执行文件的输出，可以看到一部分节被标记为了A（ALLOC）、WA（WRITE/ALLOC）或者AX（ALLOC/EXEC）。.dynsym是被标记了ALLOC的，而.symtab则没有被标记。

ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。.dynsym符号表对于动态链接可执行文件的执行来说是必须的，而.symtab符号表只是用来进行调试和链接的，有时为了节省空间，会将.symtab符号表从生产二进制文件中删掉。

## ELF重定位

重定位就是将符号定义和符号引用进行连接的过程。可重定位文件需要包含描述如何修改节内容的相关信息，从而使得可执行文件和共享目标文件能够保存进程的程序镜像所需的正确信息。重定位条目就是我们上面说的相关信息。

在重定位文件中，重定位记录保存了如何对给定的符号对应代码进行补充的相关信息。重定位实际上是一种给二进制文件打补丁的机制，如果使用了动态链接器，可以使用重定位在内存中打热补丁。假设要将两个目标文件链接到一起产生一个可执行文件。obj1.o文件中存放了调用函数foo()的代码，而函数foo()是存放在目标文件obj2.o中的。链接程序(/bin/ld)会对obj1.o和obj2.o中的重定位记录进行分析并将这两个文件链接在一起产生一个可以独立运行的可执行程序。

### 基于二进制修补的重定位代码注入

重定位代码注入是黑客、病毒制造者或者任何想修改二进制文件中代码的人常用的一种技术。在二进制文件编译完成并链接到一个可执行文件之后，通过重定位代码技术可以重新链接二进制文件。这就意味着，可以将一个目标文件注入到可执行文件中，更改可执行文件的符号表来指向新注入的功能，并对注入的目标代码进行必要的重定位，那么注入的代码就变成了可执行文件的一部分。

重定位的具体实操可以参照工具**Eresi**和本书作者所编写的ELF反编译工具**Quenya**。

## ELF动态链接

ELF支持动态链接，当一个程序使用了外部的库函数，那么整个库都会被直接编译到可执行文件中，这在处理共享库的时候就会非常有效。

当一个程序被加载进内存时，动态链接器会把需要的共享库加载并绑定到该进程的地址空间中。共享库在被编译到可执行文件中时是位置独立的，因此很容易被重定位到进程的地址空间中。一个共享库就是一个动态的ELF目标文件。在终端输入**readelf -h lib.so**命令后，会看到e_type（**ELF文件类型**）是ET_DYN。

当一个共享库被加载进一个进程的地址空间中时，一定有指向其他共享库的重定位。动态链接器会修改可执行文件中的GOT（Global Offset Table，全局偏移表）。动态链接器会使用解析好的共享库地址来修改GOT。

### 辅助向量

通过系统调用sys_execve()将程序加载到内存中时，对应的可执行文件会被映射到内存的地址空间中，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特定的对信息的设置和安排即为**辅助向量**。

程序被加载进内存，辅助向量被填充好后，控制权就交给动态链接器。动态链接器会解析要连接到进程地址空间的用于共享库的符号和重定位。默认情况下，可执行文件会动态链接到GNU C库libc.so。ldd命令能显示出一个给定的可执行文件所依赖的共享库列表。

