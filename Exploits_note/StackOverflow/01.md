# 栈溢出笔记

## 利用原理

栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是

- 程序必须向栈上写入数据。
- 写入的数据大小没有被良好地控制。

## 程序代码

```c++
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>
#define PASSWORD "1234567"

int verify_password(char *password)
{
	int authenticated;
	char buffer[44];
	authenticated = strcmp(password,PASSWORD);
	strcpy(buffer,password);//overflowed here
	return authenticated;
}

int main()
{
	int flag = 0;
	char password[1024];
	FILE *fp;
	LoadLibrary("user32.dll");//prepare for messagebox()
	if(!(fp=fopen("password.txt","rw+")))
	{
		printf("password.txt not found!\n\n");
		exit(0);
	}
	fscanf(fp,"%s",password);
	flag = verify_password(password);
	if(!flag)
	{
		printf("congratulation!\n\n");
	}
	else
	{
		printf("incorrect password!\n");
	}
	fclose(fp);
	return 0;
}
```

## 目的

对编译出来的程序，利用栈溢出实现弹窗。

## 分析

IDA逆向分析目标程序功能，得知该程序在本地读取`password.txt`文件的数据来进行校验，其中校验函数`sub_401020`的`strcpy`处存在栈溢出漏洞。

![p1-01](.\pic\1-01.png)

![p1-02](.\pic\1-02.png)

![p1-03](.\pic\1-03.png)

OD动态调试该程序，在`sub_401020`的`strcpy`处下断，f9运行，分析可知`strcpy`以ecx的值0x12FB44为源拷贝地址，以edx的值0x12FAB8为目的拷贝地址，实现将首字节地址为0x12FB44的字符串拷贝至地址0x12FAB8中，`x00`截断。

![p1-04](.\pic\1-04.png)

分析栈上0x12FAB8处的情况，可知我们可以通过在0x12FAB8处可写入不计长度的数据来覆盖当前栈上的数据，此处构成栈溢出漏洞。利用该漏洞我们可以覆写0x12FAEC处的数据，使得程序在执行到retn时能够跳转到我们复写的指令地址。

![p1-05](.\pic\1-05.png)

## shellcode

### shellcode在内存上分布

经过以上的分析，我们可以构造简单的shellcode使得程序弹窗。shellcode可在栈上的存储分布如下：

![p1-06](.\pic\1-06.png)

## shellcode编写

查询MessageBoxA()的内存地址：

1. OD加载目标程序
2. 按ALT+M，在模块栏内寻找模块USER32的内存加载地址基址 0x76F20000
3. 在vc++6.0目录下tools中，运行depends并加载一个有图形界面的程序，在左边模块树内选中USER32.DLL，在右边第二个的函数列表中寻找MessageBoxA的入口点0x0005EA71
4. 得MessageBoxA的内存地址0x76F20000 + 0x0005EA71 = 0x76F7EA71

调用MessageBoxA()时相应的汇编如下：

```assembly
xor ebx,ebx
push ebx
mov eax,esp
push ebx
push eax
push eax
push ebx
mov eax,0x76F7EA71	;MessageBoxA()的内存地址，不同机器可能不同
call eax
```

对应shellcode的hex为:

![p1-07](.\pic\1-07.png)

由此，我们可以依据该hex设计password.txt。根据shellcode在内存上的分布图，password.txt的前52个字节为调用MessageBoxA()时相应的hex（空余空间用`nop`填充）；后2个字节用于覆盖返回地址，可设计为shellcode首字节在内存上的地址。

故password.txt可设计为：

![p1-08](.\pic\1-08.png)

## 执行结果

![p1-09](.\pic\1-09.png)
















